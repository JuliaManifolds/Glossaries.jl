var documenterSearchIndex = {"docs":
[{"location":"news/#Changelog","page":"Changelog","title":"Changelog","text":"All notable Changes to the Julia package Glossaries.jl are documented in this file.\n\nThe format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"section"},{"location":"news/#[0.1.1](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.1.1)-(January-14,-2026)","page":"Changelog","title":"0.1.1 (January 14, 2026)","text":"","category":"section"},{"location":"news/#Fixed","page":"Changelog","title":"Fixed","text":"Corrected function printing logic in terms.jl where the number of arguments check was too restrictive.","category":"section"},{"location":"news/#[0.1.0](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.1.0)-(January-8,-2026)","page":"Changelog","title":"0.1.0 (January 8, 2026)","text":"","category":"section"},{"location":"news/#Added","page":"Changelog","title":"Added","text":"Initial release of Glossaries.jl","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Glossary","page":"Reference","title":"Glossary","text":"","category":"section"},{"location":"reference/#Defining-Terms","page":"Reference","title":"Defining Terms","text":"","category":"section"},{"location":"reference/#Search","page":"Reference","title":"Search","text":"","category":"section"},{"location":"reference/#Format","page":"Reference","title":"Format","text":"","category":"section"},{"location":"reference/#Internals","page":"Reference","title":"Internals","text":"","category":"section"},{"location":"reference/#Glossaries.GlossarEntry","page":"Reference","title":"Glossaries.GlossarEntry","text":"GlossarEntry\n\nAn abstract type representing a term in a glossary.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.Glossary","page":"Reference","title":"Glossaries.Glossary","text":"Glossary{T} <: GlossarEntry\n\nFields\n\nterms::Dict{Symbol, T} : A dictionary mapping term names (as symbols) to terms of type T.\n\nA glossary containing entries of type T where T is a subtype of GlossarEntry. As Glossary is a subtype of GlossarEntry, glossaries can be nested within other glossaries.\n\nConstructor\n\nGlossary(terms = Dict{Symbol, GlossarEntry}())\n\nCreates a new (empty) Glossary instance.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.@Glossary-Tuple{}","page":"Reference","title":"Glossaries.@Glossary","text":"@Glossary\n\nA macro to introduce a glossary in the current Module as well as access functions current_glossary and current_glossary!, such that one can easily work with the current active glossary in a thread-safe manner.\n\nnote: Note\nThis macro should be called only once per module, since a second call would overwrite the current active glossary in that module, which might cause even an error in Julia 1.11 or before.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Glossaries.Term","page":"Reference","title":"Glossaries.Term","text":"Term{P} <: GlossarEntry\n\nA concrete implementation of a term in a Glossary.\n\nFields\n\nproperties::Dict{Symbol, P}: A dictionary of properties associated with the term\n\nThese properties can be\n\nStrings\na function (args...; kwargs...) -> String\nother further (nested)) GlossarEntrys\n\nConstructors\n\nTerm(properties = Dict{Symbol, Union{GlossarEntry, String, <:Function}}())\n\nCreate a new empty Term with the given name.\n\nTerm(name::String)\n\nCreate a new empty Term and directly set its :name.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.getindex-Tuple{Glossaries.Glossary, Symbol}","page":"Reference","title":"Base.getindex","text":"getindex(glossary::Glossary, key::Symbol)\nglossary[key::Symbol]\n\nAccess the entry at key in the given Glossary glossary.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getindex-Tuple{Glossaries.Term, Symbol}","page":"Reference","title":"Base.getindex","text":"getindex(term::Term, key::Symbol)\nterm[key::Symbol]\n\nAccess the property key in the given Term term.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.add!-Union{Tuple{Q}, Tuple{P}, Tuple{Glossaries.Term{P}, Symbol, Q}} where {P, Q<:P}","page":"Reference","title":"Glossaries.add!","text":"add!(term::Term{P}, name::Symbol, value::Q) where {P, Q<:P}\n\nAdd a property name with value value for the given Term term.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.define!","page":"Reference","title":"Glossaries.define!","text":"define!(glossary::Glossary, key::Symbol, name::String)\ndefine!(glossary::Glossary, key::Symbol, term::T) where {T <: GlossarEntry}\ndefine!(wm::Module, key::Symbol, name::String)\ndefine!(wm::Module, key::Symbol, term::T) where {T <: GlossarEntry}\n\nDefine a new Term in the Glossary glossary at key or a new Term(name) if just providing a string.\n\nIf a Module wm is given, the term is added to the current active glossary\n\n\n\n\n\n","category":"function"},{"location":"reference/#Glossaries.define!-2","page":"Reference","title":"Glossaries.define!","text":"define!(glossary::Glossary, key::Symbol, name::String)\ndefine!(glossary::Glossary, key::Symbol, term::T) where {T <: GlossarEntry}\ndefine!(wm::Module, key::Symbol, name::String)\ndefine!(wm::Module, key::Symbol, term::T) where {T <: GlossarEntry}\n\nDefine a new Term in the Glossary glossary at key or a new Term(name) if just providing a string.\n\nIf a Module wm is given, the term is added to the current active glossary\n\n\n\n\n\n","category":"function"},{"location":"reference/#Glossaries.define!-Tuple{Glossaries.Glossary, Symbol, Symbol, Vararg{Any}}","page":"Reference","title":"Glossaries.define!","text":"define!(wm::Module, entry::Symbol, property::Symbol, args...)\ndefine!(glossary::Glossary, entry::Symbol, property::Symbol, args...)\n\nDefine a property property with value args... for the Term at the key in Glossary glossary. If the term does not exist yet, it is created as an empty Term().\n\nIf a Module wm is given, the term is added to the current active glossary of that module.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.define!-Tuple{Module, Glossaries.Glossary}","page":"Reference","title":"Glossaries.define!","text":"define!(wm::Module, glossary::Glossary)\n\nSet the current active glossary in the given module wm to glossary. Soo also current_glossary!.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.define!-Tuple{Module, Symbol, Symbol, Vararg{Any}}","page":"Reference","title":"Glossaries.define!","text":"define!(wm::Module, entry::Symbol, property::Symbol, args...)\ndefine!(glossary::Glossary, entry::Symbol, property::Symbol, args...)\n\nDefine a property property with value args... for the Term at the key in Glossary glossary. If the term does not exist yet, it is created as an empty Term().\n\nIf a Module wm is given, the term is added to the current active glossary of that module.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.define!-Union{Tuple{S}, Tuple{Module, Symbol, S}} where S<:Glossaries.GlossarEntry","page":"Reference","title":"Glossaries.define!","text":"define!(glossary::Glossary, key::Symbol, name::String)\ndefine!(glossary::Glossary, key::Symbol, term::T) where {T <: GlossarEntry}\ndefine!(wm::Module, key::Symbol, name::String)\ndefine!(wm::Module, key::Symbol, term::T) where {T <: GlossarEntry}\n\nDefine a new Term in the Glossary glossary at key or a new Term(name) if just providing a string.\n\nIf a Module wm is given, the term is added to the current active glossary\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.define!-Union{Tuple{S}, Tuple{T}, Tuple{Glossaries.Glossary{T}, Symbol, S}} where {T, S<:T}","page":"Reference","title":"Glossaries.define!","text":"define!(glossary::Glossary, key::Symbol, name::String)\ndefine!(glossary::Glossary, key::Symbol, term::T) where {T <: GlossarEntry}\ndefine!(wm::Module, key::Symbol, name::String)\ndefine!(wm::Module, key::Symbol, term::T) where {T <: GlossarEntry}\n\nDefine a new Term in the Glossary glossary at key or a new Term(name) if just providing a string.\n\nIf a Module wm is given, the term is added to the current active glossary\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.@define!-Tuple","page":"Reference","title":"Glossaries.@define!","text":"@define!(entry::Symbol, name::String)\n@define!(entry::Symbol, term::T) where {T <: GlossarEntry}\n@define!(entry::Symbol, property::Symbol, args...)\n\nA macro to define a new Term in the current_glossary of the current module or a property of a Term. If given a String name is provided, a new Term(name) is created and added to the current glossary.\n\nSince this requires to call @__MODULE__, this is wrapped in a macro for convenience.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Glossaries.Glossary-Tuple{Any}","page":"Reference","title":"Glossaries.Glossary","text":"(glossary::Glossary)(query)\n\nGiven a Glossary instance, this allows to search for a query string in all its terms/entries by calling glossary(query).\n\nGlossaries.Glossary(Dict{Symbol,Glossaries.GlossarEntry}([\n    :title => Glossaries.Term(\"A simple Glossary Test\"),\n    :names => Glossaries.Glossary(Dict{Symbol,Glossaries.Term}([\n        :Anton => Glossaries.Term(\"Anton Test\"),\n        :Egon => Glossaries.Term(\"Egon Est\"),\n        ])),\n    ]))\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.search_in-Tuple{Glossaries.Term, Any}","page":"Reference","title":"Glossaries.search_in","text":"search_in(entry::Term, query::AbstractString)\n\nA small internal function to search in a term. To match the glossary search interface, this method returns a vector of length one containing the pair (nothing, term) if there is a match, otherwise an empty vector.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.search_in-Union{Tuple{T}, Tuple{Glossaries.Glossary{T}, Any}} where T","page":"Reference","title":"Glossaries.search_in","text":"search_in(glossary::Glossary{T}, query) where {T}\n\nSearch for a query string in all terms/entries of a Glossary. Internally, this function calls occursin, so the query can be any needle that function accepts.\n\nThis returns an array of Pairs where the first element is the Symbol or vector of Symbols where to find the corresponding term, and the second element is the term itself.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Glossaries.Argument","page":"Reference","title":"Glossaries.Argument","text":"Argument <: TermFormatter\n\nA format representing a function argument.\n\nGiven a Term, this formatter expects the following properties to be set:\n\n:name: the name of the argument\n:type: the type of the argument (optional)\n:description: the description of the argument\n\nThis formatter prints\n\n- `name::type`: description\n\nNote that both the name and the type are set in code formatting.\n\nThis format additionally accepts two keyword arguments, that are hence are hence not passed to the underlying term:\n\nname::String=\"\": if given, this name is used instead of the term's :name property.\nadd_properties::Vector{Symbol}=Symbol[]: a vector of additional properties to add to the output after the description.\n\nAll arguments and keyword arguments other than these are passed to the underlying property formatting,\n\nFields\n\nshow_type::Bool: whether to show the type of the argument\n\nConstructor\n\nArgument(show_type::Bool = true)\n@Argument(show_type::Bool = true)\n\nCreate a new Argument formatter, where the macro variant takes the current modules glossary as default, see the different forms to call a formatter at TermFormatter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.Field","page":"Reference","title":"Glossaries.Field","text":"Field <: TermFormatter\n\nA format representing a struct field.\n\nGiven a Term, this formatter expects the following properties to be set:\n\n:name: the name of the field\n:type: the type of the field (optional)\n:description: the description of the field\n\nThis formatter prints\n\n- `name::type`: description\n\nNote that both the name and the type are set in code formatting.\n\nThis format additionally accepts two keyword arguments, that are hence are hence not passed to the underlying term:\n\nadd_properties::Vector{Symbol}=Symbol[]: a vector of additional properties to add to the output after the description.\nname::String=\"\": if given, this name is used instead of the term's :name property.\ntype::String=\"\": if given, this type is used instead of the term's :type property.\n\nAll arguments and keyword arguments other than these are passed to the underlying property formatting,\n\nFields\n\nshow_type::Bool: whether to show the type of the argument\n\nConstructor\n\nField(show_type::Bool = true)\n@Field(show_type::Bool = true)\n\nCreate a new Field formatter, where the macro variant takes the current modules glossary as default, see the different forms to call a formatter at TermFormatter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.Keyword","page":"Reference","title":"Glossaries.Keyword","text":"Keyword <: TermFormatter\n\nA format representing a function keyword argument. Keyword arguments are passed to :type, and :default, and :description properties.\n\nThis formatter expects the following properties to be set:\n\n:name: the name of the keyword argument\n:type: the type of the keyword argument (optional)\n:default: the default value of the keyword argument (optional)\n:description: the description of the keyword argument\n\nThis formatter prints\n\n- `name::type = default`: description\n\nNote that the name, the type and the default are set in code formatting.\n\nThis format additionally accepts two keyword arguments, that are hence are hence not passed to the underlying term:\n\nname::String=\"\": if given, this name is used instead of the term's :name property.\nadd_properties::Vector{Symbol}=Symbol[]: a vector of additional properties to add to the output after the description.\ndefault::String=\"\": the default value to use instead of the stored :default property.\n\nAll arguments and keyword arguments other than these are passed to the underlying property formatting,\n\nFields\n\nshow_type::Bool: whether to show the type of the keyword argument\n\nConstructor\n\nKeyword(show_type::Bool = true)\n@Keyword(show_type::Bool = true)\n\nCreate a new Keyword formatter, where the macro variant takes the current modules glossary as default, see the different forms to call a formatter at TermFormatter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.Math","page":"Reference","title":"Glossaries.Math","text":"Math <: TermFormatter\n\nprint the math format. This formatter of a term passes all arguments and keyword arguments to the underlying term formatting for the :math property.\n\nConstructor\n\nMath()\n@Math()\n\nCreate a new Math formatter, where the macro variant takes the current modules glossary as default, see the different forms to call a formatter at TermFormatter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.MathTerm","page":"Reference","title":"Glossaries.MathTerm","text":"MathTerm <: TermFormatter\n\nA formatter for mathematical terms.\n\nThis formatter expects the following properties to be set:\n\n:description: the description of the term\n:math: the math expression of the term\n\nThis formatter prints\n\ndescription delimiter math delimiter\n\nFields\n\ndelimiter::String: the delimiter to use around the math expression\n\nConstructor\n\nMathTerm(delimiter::String=\"``\")\n\nUse the default Julia documentation math delimiter ``...``.\n\nConstructor\n\nMathTerm(delimiter::String=\"``\")\n@MathTerm(delimiter::String=\"``\")\n\nCreate a new MathTerm formatter, where the macro variant takes the current modules glossary as default, see the different forms to call a formatter at TermFormatter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.Plain","page":"Reference","title":"Glossaries.Plain","text":"Plain <: TermFormatter\n\nA plain format representing just the terms :name.\n\nIt then prints really just the name of the term.\n\nConstructor\n\nPlain()\n@Plain()\n\nCreate a new Plain formatter, where the macro variant takes the current modules glossary as default, see the different forms to call a formatter at TermFormatter.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.TermFormatter","page":"Reference","title":"Glossaries.TermFormatter","text":"TermFormatter\n\nA format for glossary terms. It always acts as a functor with the following methods:\n\n(tf::TermFormatter)(keys::Vector{Symbol}; kwargs...)\n(tf::TermFormatter)(glossary::Glossary, keys::Vector{Symbol}; kwargs...)\n\nformat all given keys of a glossary using the format tf. If the glossary is not given, the current_glossary is used, if no keys are given, all keys of the glossary are used.\n\n(tf::TermFormatter)(key::Symbol, args...; kwargs...)\n(tf::TermFormatter)(glossary::Glossary, key::Symbol, args...; kwargs...)\n\nformat the given key of a glossary using the format tf. If the glossary is not given, the current_glossary is used. All additional args... and kwargs... are passed to the underlying term formatting.\n\nFormatting a single Term is done by calling\n\n(tf::TermFormatter)(term::Term, args...; kwargs...)\n\nwhere term is the Term to format. This should be implemented by all subtypes of TermFormatter. To what extend a certain formatter does support additional args... depends on the formatter. All should accept kwargs....\n\n\n\n\n\n","category":"type"},{"location":"reference/#Glossaries.current_glossary","page":"Reference","title":"Glossaries.current_glossary","text":"current_glossary()\n\nReturns the current active glossary (or the last glossary created). Returns nothing if there is no current active glossary.\n\nThe access is thread-safe, since it also uses a lock.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Glossaries.current_glossary!","page":"Reference","title":"Glossaries.current_glossary!","text":"current_glossary!(glossary)\n\nSet glossary as the current active glossary.\n\nThe access is thread-safe, since it also uses a lock.\n\n\n\n\n\n","category":"function"},{"location":"#Welcome-to-Glossaries.jl","page":"Home","title":"ðŸ—ƒï¸ Welcome to Glossaries.jl","text":"","category":"section"},{"location":"#Glossaries.Glossaries","page":"Home","title":"Glossaries.Glossaries","text":"ðŸ—ƒï¸ Glossaries.jl â€“ manage a glossary for arguments, keywords and other snippets and terms for   the documentation of your Julia package.\n\nA Julia package for managing glossaries of terms, including their metadata, for example their mathematical notation.\n\nThe package further provides several formatting options for displaying terms in different contexts, e.g., as function arguments or keyword arguments or within mathematical formulas.\n\nðŸ“š Documentation: juliamanifolds.github.io/Glossaries.jl/\nðŸ“¦ Repository: github.com/JuliaManifolds/Glossaries.jl\nðŸ’¬ Discussions: github.com/JuliaManifolds/Glossaries.jl/discussions\nðŸŽ¯ Issues: github.com/JuliaManifolds/Glossaries.jl/issues\n\n\n\n\n\n","category":"module"},{"location":"tutorials/getstarted/#Get-Started-with-Glossaries.jl","page":"Get started with Glossaries.jl","title":"Get Started with Glossaries.jl","text":"Ronny Bergmann 2025-12-26\n\nThis tutorial provides a short introduction to using the package Glossaries.jl for managing either a small own glossary or a glossary for a certain package.","category":"section"},{"location":"tutorials/getstarted/#Introduction","page":"Get started with Glossaries.jl","title":"Introduction","text":"A Glossary is, according to Wikipedia, a list of Terms in some domain knowledge. The goal of this package is to easily define such glossaries but also to format or print certain terms or lists of terms.\n\nAs a guiding example, consider the usual set of variables that appear in signatures of a package. In a documentation we would hence often repeat variable names, their types, maybe their default values, or their short description in a list of arguments or keywords.\n\nAs a remedy one can define a glossary of common variables, but also terms, short definitions or remarks, that can then be reused.","category":"section"},{"location":"tutorials/getstarted/#Starting-a-new-Glossary","page":"Get started with Glossaries.jl","title":"Starting a new Glossary","text":"To start a new glossary, you first need to create a Glossary object. This can be done by simply calling the constructor:\n\nusing Glossaries\ng = Glossaries.Glossary()\n\nAn Empty Glossary\n\nWhen working with just one Glossary, one can also use @Glossary, which creates a current_glossary in the current module. Each Term within a Glossary consists of a list of properties. There are either Strings or functions returning strings to allow for a certain amount of parametrization. Terms within a Glossary are stored at a certain symbol.\n\nFor our example, consider we have a recurring variable named duck of type AbstractDuck.\n\nWe enter this for example as\n\nGlossaries.define!(g, :duck, :name, \"duck\")\nGlossaries.define!(g, :duck, :type, \"AbstractDuck\")\nGlossaries.define!(g, :duck, :description, \"A yellow duck\")\nGlossaries.define!(g, :duck, :default, \"`[`YellowDuck`](@ref)`()\")\n\nGlossary with 1 terms:\n* :duck Term â€œduckâ€\n      - :default    `[`YellowDuck`](@ref)`()\n      - :type   AbstractDuck\n      - :name   duck\n      - :description    A yellow duck\n\nNote that since the type and the default are considered to be typeset in code, we have to start the default with ending a code block before adding the @ref markdown link.\n\nAgain, you can also use @define!(:duck, ...) to add entries to the glossary of the current module.\n\nWe can also create a Term manually and add it to g afterwards. Since the name is a usual property, providing a string, sets the :name property.\n\nt = Glossaries.Term(\"habitat\")\nt[:type] = \"AbstractHabitat\"\nt[:description] = (var=\"duck\") -> \"A habitat of a `$var`\"\nt[:default] = \"Lake()\"\n\n\"Lake()\"\n\nAs already mentioned, entries can also be functions. Here the description can be used to also specify that the habitat variable might refer to another arguments habitat than that of the duck.\n\nand we can add the term to the glossary either also by using g[:habitat] = t or with\n\nGlossaries.define!(g, :habitat, t)\n\nGlossary with 2 terms:\n* :habitat  Term â€œhabitatâ€\n      - :default    Lake()\n      - :type   AbstractHabitat\n      - :name   habitat\n      - :description    A habitat of a `duck`\n* :duck Term â€œduckâ€\n      - :default    `[`YellowDuck`](@ref)`()\n      - :type   AbstractDuck\n      - :name   duck\n      - :description    A yellow duck","category":"section"},{"location":"tutorials/getstarted/#Using-a-Glossary","page":"Get started with Glossaries.jl","title":"Using a Glossary","text":"If we now have a function to check whether a certain duck fits into a habitat, e.g.Â fits(duck, habitat), we can use a TermFormatter to generate its argument list.\n\n_arg = Glossaries.Argument()\n_arg(g, [:duck, :habitat]) |> print\n\n- `duck::AbstractDuck`: A yellow duck\n- `habitat::AbstractHabitat`: A habitat of a `duck`\n\nAgain, using @Argument allows to omit the first parameter, since that formatter would use the glossary of the current module.\n\nSimilarly if we want to generate that for a function something(; kwargs...) where both are keyword arguments. We get using Keyword\n\n_kw = Glossaries.Keyword()\n_kw(g, [:duck, :habitat]) |> print\n\n- `duck::AbstractDuck = `[`YellowDuck`](@ref)`()`: A yellow duck\n- `habitat::AbstractHabitat = Lake()`: A habitat of a `duck`\n\nnote that in this format, the default is printed as well. Still, in both cases the information throughout multiple documentation strings is not only consistent, but if we had a typo, there is a single place to fix this, namely where we define the glossary terms.","category":"section"}]
}
